services:
  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - pgdata:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    env_file:
      - ./.env
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    volumes:
      - ./data/minio:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/ready"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 20s

  postgres-backup:
    build:
      context: ./backup
      dockerfile: Dockerfile
    env_file:
      - ./.env
    environment:
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      BACKUP_DIR: /backups
      BACKUP_RETENTION: ${BACKUP_RETENTION:-7}
      BACKUP_HOUR: ${BACKUP_HOUR:-2}
      BACKUP_S3_ENABLED: ${BACKUP_S3_ENABLED:-false}
      BACKUP_S3_BUCKET: ${BACKUP_S3_BUCKET:-}
      RUN_ON_STARTUP: ${BACKUP_RUN_ON_STARTUP:-true}
    volumes:
      - ./data/backups:/backups
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

  minio-init:
    image: minio/mc:latest
    env_file:
      - ./.env
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      mc alias set local http://minio:9000 ${MINIO_ROOT_USER} ${MINIO_ROOT_PASSWORD} &&
      mc mb --ignore-existing local/relay &&
      mc anonymous set none local/relay
      "
    restart: "no"

  control-plane-migrate:
    build:
      context: ../apps/control-plane
      dockerfile: Dockerfile
    env_file:
      - ./.env
    environment:
      DATABASE_URL: ${DATABASE_URL}
    depends_on:
      postgres:
        condition: service_healthy
    command: ["python", "-m", "alembic", "upgrade", "head"]
    restart: "no"

  control-plane:
    build:
      context: ../apps/control-plane
      dockerfile: Dockerfile
    env_file:
      - ./.env
    environment:
      DATABASE_URL: ${DATABASE_URL}
      JWT_SECRET: ${JWT_SECRET}
      BOOTSTRAP_ADMIN_EMAIL: ${BOOTSTRAP_ADMIN_EMAIL:-}
      BOOTSTRAP_ADMIN_PASSWORD: ${BOOTSTRAP_ADMIN_PASSWORD:-}
      RELAY_PUBLIC_URL: ${RELAY_PUBLIC_URL}
    volumes:
      - ./data/uploads:/app/app/static/uploads
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      control-plane-migrate:
        condition: service_completed_successfully
      minio-init:
        condition: service_completed_successfully
    healthcheck:
      test:
        [
          "CMD",
          "python",
          "-c",
          "import sys,urllib.request;sys.exit(0) if urllib.request.urlopen('http://127.0.0.1:8000/health').status == 200 else sys.exit(1)",
        ]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 15s

  webhook-worker:
    build:
      context: ../apps/control-plane
      dockerfile: Dockerfile
    env_file:
      - ./.env
    environment:
      DATABASE_URL: ${DATABASE_URL}
      WORKER_INTERVAL: ${WEBHOOK_WORKER_INTERVAL:-30}
      WORKER_BATCH_SIZE: ${WEBHOOK_WORKER_BATCH_SIZE:-50}
    command: ["python", "-m", "app.workers.webhook_worker"]
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      control-plane-migrate:
        condition: service_completed_successfully

  email-worker:
    build:
      context: ../apps/control-plane
      dockerfile: Dockerfile
    env_file:
      - ./.env
    environment:
      DATABASE_URL: ${DATABASE_URL}
      EMAIL_ENABLED: ${EMAIL_ENABLED:-false}
      SMTP_HOST: ${SMTP_HOST:-}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER:-}
      SMTP_PASSWORD: ${SMTP_PASSWORD:-}
      SMTP_USE_TLS: ${SMTP_USE_TLS:-true}
      EMAIL_FROM: ${EMAIL_FROM:-}
      EMAIL_REPLY_TO: ${EMAIL_REPLY_TO:-}
      WORKER_INTERVAL: ${EMAIL_WORKER_INTERVAL:-60}
      WORKER_BATCH_SIZE: ${EMAIL_WORKER_BATCH_SIZE:-100}
    command: ["python", "-m", "app.workers.email_worker"]
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      control-plane-migrate:
        condition: service_completed_successfully

  # placeholder: relay server (будет подключён/собран агентом)
  relay-server:
    build:
      context: ../forks/relay-server-template
    depends_on:
      minio:
        condition: service_healthy
      minio-init:
        condition: service_completed_successfully
    volumes:
      - ./relay/relay.toml:/app/relay.toml:ro
      - ./data/relay:/app/data
    restart: unless-stopped
    expose:
      - "8080"
      - "9090"
    healthcheck:
      # Note: Container has minimal shell without curl/pgrep. Using /proc check.
      test: ["CMD-SHELL", "grep -q relay /proc/1/cmdline || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 20s

  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=15d'
      - '--web.enable-lifecycle'
    restart: unless-stopped
    depends_on:
      control-plane:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:9090/-/ready"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 10s

  grafana:
    image: grafana/grafana:latest
    environment:
      GF_SECURITY_ADMIN_USER: ${GRAFANA_ADMIN_USER:-admin}
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD:-admin}
      GF_USERS_ALLOW_SIGN_UP: "false"
      GF_AUTH_ANONYMOUS_ENABLED: "false"
    volumes:
      - ./grafana/grafana.ini:/etc/grafana/grafana.ini:ro
      - ./grafana/provisioning:/etc/grafana/provisioning:ro
      - ./grafana/dashboards:/var/lib/grafana/dashboards:ro
      - grafana-data:/var/lib/grafana
    restart: unless-stopped
    depends_on:
      prometheus:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:3000/api/health"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 20s

  web-publish:
    build:
      context: ../apps/web-publish
      dockerfile: Dockerfile
    environment:
      CONTROL_PLANE_URL: http://control-plane:8000
      PUBLIC_CONTROL_PLANE_URL: https://cp.${DOMAIN_BASE}
      PUBLIC_WEB_DOMAIN: ${WEB_PUBLISH_DOMAIN:-}
      ORIGIN: https://${WEB_PUBLISH_DOMAIN:-localhost}
    depends_on:
      control-plane:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:3000/', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 10s

  caddy:
    image: caddy:2
    ports:
      - "80:80"
      - "443:443"
    env_file:
      - ./.env
    environment:
      DOMAIN_BASE: ${DOMAIN_BASE}
      ACME_EMAIL: ${ACME_EMAIL}
      WEB_PUBLISH_DOMAIN: ${WEB_PUBLISH_DOMAIN:-web-publish.disabled}
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - ./data/caddy:/data
      - ./data/caddy_config:/config
    depends_on:
      - control-plane
      - relay-server
      - grafana
      - web-publish
    restart: unless-stopped
volumes:
  pgdata:
  prometheus-data:
  grafana-data: